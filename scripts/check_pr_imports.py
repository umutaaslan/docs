#!/usr/bin/env python3
"""Check PR diffs for unnecessary `langchain_core` imports.

This script analyzes PR diffs to identify imports that should use `langchain`
instead of `langchain_core` based on the `import_mappings.json` file generated by
`check_import_mappings.py`.
"""

import json
import re
import subprocess
import sys
from pathlib import Path
from typing import Any


def load_import_mappings() -> dict[str, Any]:
    """Load the import mappings from JSON file."""
    mappings_file = Path("scripts/import_mappings.json")
    if not mappings_file.exists():
        print(
            "Error: import_mappings.json not found. Run check_import_mappings.py first."
        )
        sys.exit(1)

    with mappings_file.open() as f:
        return json.load(f)


def get_pr_diff() -> str:
    """Get the diff for the current PR."""
    try:
        # Get the base branch (usually main)
        result = subprocess.run(
            ["git", "merge-base", "HEAD", "origin/main"],  # noqa: S607
            capture_output=True,
            text=True,
            check=True,
        )
        base_sha = result.stdout.strip()

        # Get the diff from base to HEAD
        result = subprocess.run(  # noqa: S603
            ["git", "diff", base_sha, "HEAD"],  # noqa: S607
            capture_output=True,
            text=True,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        print(f"Error getting PR diff: {e}")
        sys.exit(1)
    else:
        return result.stdout


def build_mapping_dict(mappings: dict[str, Any]) -> dict[str, str]:
    """Build a dictionary mapping `langchain_core` imports to `langchain` imports."""
    mapping_dict = {}

    for analysis in mappings.get("analysis", []):
        exported_from_core = analysis.get("exported_from_core", {})
        if not exported_from_core:
            continue

        # Extract module path from file path
        file_path = analysis.get("file", "")
        if not file_path:
            continue

        # Convert file path to module path
        # e.g., /path/to/langchain/messages/__init__.py -> langchain.messages
        parts = file_path.split("/")
        try:
            langchain_idx = parts.index("langchain")
            module_parts = parts[langchain_idx:-1]  # Exclude __init__.py
            langchain_module = ".".join(module_parts)
        except (ValueError, IndexError):
            continue

        # Map each exported symbol
        for symbol, info in exported_from_core.items():
            core_module = info.get("module", "")
            if core_module:
                mapping_dict[f"{core_module}.{symbol}"] = f"{langchain_module}.{symbol}"
                # Also map module-level imports
                if core_module not in mapping_dict:
                    mapping_dict[core_module] = langchain_module

    return mapping_dict


def check_import_line(line: str, mapping_dict: dict[str, str]) -> list[dict[str, str]]:
    """Check a single import line for incorrect `langchain_core` imports."""
    issues = []
    line = line.strip()

    # Match different import patterns
    patterns = [
        r"from\s+(langchain_core\.\S+)\s+import\s+(.+)",  # Matches `from langchain_core.module import ...`  # noqa: E501
        r"import\s+(langchain_core\.\S+)",  # Matches `import langchain_core.module`
    ]

    for i, pattern in enumerate(patterns):
        match = re.match(pattern, line)
        if match:
            if i == 0:  # from ... import ... pattern (2 groups)
                # from ... import ... pattern
                core_module = match.group(1)
                imports = match.group(2)

                # Check if this module should be imported from langchain instead
                if core_module in mapping_dict:
                    langchain_module = mapping_dict[core_module]
                    suggested_line = f"from {langchain_module} import {imports}"
                    issues.append(
                        {
                            "original": line,
                            "suggested": suggested_line,
                            "reason": (
                                f"Import from {langchain_module} instead "
                                f"of {core_module}"
                            ),
                        }
                    )
                else:
                    # Check individual imports
                    import_list = [imp.strip() for imp in imports.split(",")]
                    problematic_imports = []
                    for imp in import_list:
                        # Clean up import (remove aliases, etc.)
                        clean_imp = imp.split(" as ")[0].strip()
                        full_import = f"{core_module}.{clean_imp}"
                        if full_import in mapping_dict:
                            problematic_imports.append(clean_imp)

                    if problematic_imports:
                        # Find the langchain module for these imports
                        first_problematic = f"{core_module}.{problematic_imports[0]}"
                        suggested_module = mapping_dict[first_problematic].rsplit(
                            ".", 1
                        )[0]
                        suggested_line = f"from {suggested_module} import {imports}"
                        issues.append(
                            {
                                "original": line,
                                "suggested": suggested_line,
                                "reason": (
                                    "These imports are re-exported "
                                    f"from {suggested_module}"
                                ),
                            }
                        )
            else:
                # import ... pattern
                core_module = match.group(1)
                if core_module in mapping_dict:
                    langchain_module = mapping_dict[core_module]
                    suggested_line = f"import {langchain_module}"
                    issues.append(
                        {
                            "original": line,
                            "suggested": suggested_line,
                            "reason": (
                                f"Import {langchain_module} instead of {core_module}"
                            ),
                        }
                    )

    return issues


def analyze_diff(diff: str, mapping_dict: dict[str, str]) -> list[dict[str, Any]]:
    """Analyze the diff for import issues."""
    issues: list[dict[str, Any]] = []
    current_file = None
    line_number = 0

    for line in diff.split("\n"):
        if line.startswith("+++"):
            # New file
            current_file = line[6:]  # Remove "+++ b/"
            line_number = 0
        elif line.startswith("@@"):
            # Hunk header - extract line number
            match = re.search(r"\+(\d+)", line)
            if match:
                line_number = int(match.group(1))
        elif line.startswith("+") and not line.startswith("+++"):
            # Added line
            content = line[1:]  # Remove the "+"

            # Check for import statements
            if "import" in content and "langchain_core" in content:
                import_issues = check_import_line(content, mapping_dict)
                issues.extend(
                    {
                        "file": current_file,
                        "line": line_number,
                        **issue,
                    }
                    for issue in import_issues
                )

            line_number += 1
        elif not line.startswith("-") and current_file is not None:
            # Context line (not removed, not added, not a header)
            line_number += 1

    return issues


def main():
    """Entrypoint."""
    mappings = load_import_mappings()
    mapping_dict = build_mapping_dict(mappings)
    diff = get_pr_diff()

    print("Analyzing diff for import issues...")
    issues = analyze_diff(diff, mapping_dict)

    if not issues:
        print("✅ No import issues found!")
        return

    print(f"❌ Found {len(issues)} import issues:")
    print()

    for issue in issues:
        print(f"File: {issue['file']}")
        print(f"Line: {issue['line']}")
        print(f"Issue: {issue['reason']}")
        print(f"Current:   {issue['original']}")
        print(f"Suggested: {issue['suggested']}")
        print("-" * 80)

    print(f"\n❌ Found {len(issues)} import issues that need to be fixed.")
    sys.exit(1)


if __name__ == "__main__":
    main()
